/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * avito-tech-assignment-winter-2025-server-swagger üöÄ
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
    DataTag,
    DefinedInitialDataOptions,
    DefinedUseQueryResult,
    MutationFunction,
    QueryFunction,
    QueryKey,
    UndefinedInitialDataOptions,
    UseMutationOptions,
    UseMutationResult,
    UseQueryOptions,
    UseQueryResult,
} from '@tanstack/react-query'
import axios from 'axios'
import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios'
import type { GetItemsId404, Items } from '../avitoTechAssignmentWinter2025ServerSwagger.schemas'

export const postItems = (items: Items, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
    return axios.post(`http://localhost:3000/items`, items, options)
}

export const getPostItemsMutationOptions = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postItems>>, TError, { data: Items }, TContext>
    axios?: AxiosRequestConfig
}): UseMutationOptions<Awaited<ReturnType<typeof postItems>>, TError, { data: Items }, TContext> => {
    const mutationKey = ['postItems']
    const { mutation: mutationOptions, axios: axiosOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, axios: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof postItems>>, { data: Items }> = props => {
        const { data } = props ?? {}

        return postItems(data, axiosOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type PostItemsMutationResult = NonNullable<Awaited<ReturnType<typeof postItems>>>
export type PostItemsMutationBody = Items
export type PostItemsMutationError = AxiosError<unknown>

export const usePostItems = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof postItems>>, TError, { data: Items }, TContext>
    axios?: AxiosRequestConfig
}): UseMutationResult<Awaited<ReturnType<typeof postItems>>, TError, { data: Items }, TContext> => {
    const mutationOptions = getPostItemsMutationOptions(options)

    return useMutation(mutationOptions)
}
export const getItems = (options?: AxiosRequestConfig): Promise<AxiosResponse<Items[]>> => {
    return axios.get(`http://localhost:3000/items`, options)
}

export const getGetItemsQueryKey = () => {
    return [`http://localhost:3000/items`] as const
}

export const getGetItemsQueryOptions = <
    TData = Awaited<ReturnType<typeof getItems>>,
    TError = AxiosError<unknown>,
>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItems>>, TError, TData>>
    axios?: AxiosRequestConfig
}) => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetItemsQueryKey()

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItems>>> = ({ signal }) =>
        getItems({ signal, ...axiosOptions })

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getItems>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsQueryResult = NonNullable<Awaited<ReturnType<typeof getItems>>>
export type GetItemsQueryError = AxiosError<unknown>

export function useGetItems<TData = Awaited<ReturnType<typeof getItems>>, TError = AxiosError<unknown>>(options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItems>>, TError, TData>> &
        Pick<
            DefinedInitialDataOptions<
                Awaited<ReturnType<typeof getItems>>,
                TError,
                Awaited<ReturnType<typeof getItems>>
            >,
            'initialData'
        >
    axios?: AxiosRequestConfig
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItems<TData = Awaited<ReturnType<typeof getItems>>, TError = AxiosError<unknown>>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItems>>, TError, TData>> &
        Pick<
            UndefinedInitialDataOptions<
                Awaited<ReturnType<typeof getItems>>,
                TError,
                Awaited<ReturnType<typeof getItems>>
            >,
            'initialData'
        >
    axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItems<TData = Awaited<ReturnType<typeof getItems>>, TError = AxiosError<unknown>>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItems>>, TError, TData>>
    axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetItems<TData = Awaited<ReturnType<typeof getItems>>, TError = AxiosError<unknown>>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItems>>, TError, TData>>
    axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetItemsQueryOptions(options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }

    query.queryKey = queryOptions.queryKey

    return query
}

export const deleteItemsId = (id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
    return axios.delete(`http://localhost:3000/items/${id}`, options)
}

export const getDeleteItemsIdMutationOptions = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteItemsId>>, TError, { id: string }, TContext>
    axios?: AxiosRequestConfig
}): UseMutationOptions<Awaited<ReturnType<typeof deleteItemsId>>, TError, { id: string }, TContext> => {
    const mutationKey = ['deleteItemsId']
    const { mutation: mutationOptions, axios: axiosOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, axios: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteItemsId>>, { id: string }> = props => {
        const { id } = props ?? {}

        return deleteItemsId(id, axiosOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type DeleteItemsIdMutationResult = NonNullable<Awaited<ReturnType<typeof deleteItemsId>>>

export type DeleteItemsIdMutationError = AxiosError<unknown>

export const useDeleteItemsId = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof deleteItemsId>>, TError, { id: string }, TContext>
    axios?: AxiosRequestConfig
}): UseMutationResult<Awaited<ReturnType<typeof deleteItemsId>>, TError, { id: string }, TContext> => {
    const mutationOptions = getDeleteItemsIdMutationOptions(options)

    return useMutation(mutationOptions)
}
export const getItemsId = (id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Items>> => {
    return axios.get(`http://localhost:3000/items/${id}`, options)
}

export const getGetItemsIdQueryKey = (id: string) => {
    return [`http://localhost:3000/items/${id}`] as const
}

export const getGetItemsIdQueryOptions = <
    TData = Awaited<ReturnType<typeof getItemsId>>,
    TError = AxiosError<GetItemsId404>,
>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsId>>, TError, TData>>
        axios?: AxiosRequestConfig
    },
) => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetItemsIdQueryKey(id)

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getItemsId>>> = ({ signal }) =>
        getItemsId(id, { signal, ...axiosOptions })

    return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getItemsId>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetItemsIdQueryResult = NonNullable<Awaited<ReturnType<typeof getItemsId>>>
export type GetItemsIdQueryError = AxiosError<GetItemsId404>

export function useGetItemsId<TData = Awaited<ReturnType<typeof getItemsId>>, TError = AxiosError<GetItemsId404>>(
    id: string,
    options: {
        query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsId>>, TError, TData>> &
            Pick<
                DefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getItemsId>>,
                    TError,
                    Awaited<ReturnType<typeof getItemsId>>
                >,
                'initialData'
            >
        axios?: AxiosRequestConfig
    },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsId<TData = Awaited<ReturnType<typeof getItemsId>>, TError = AxiosError<GetItemsId404>>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsId>>, TError, TData>> &
            Pick<
                UndefinedInitialDataOptions<
                    Awaited<ReturnType<typeof getItemsId>>,
                    TError,
                    Awaited<ReturnType<typeof getItemsId>>
                >,
                'initialData'
            >
        axios?: AxiosRequestConfig
    },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetItemsId<TData = Awaited<ReturnType<typeof getItemsId>>, TError = AxiosError<GetItemsId404>>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsId>>, TError, TData>>
        axios?: AxiosRequestConfig
    },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetItemsId<TData = Awaited<ReturnType<typeof getItemsId>>, TError = AxiosError<GetItemsId404>>(
    id: string,
    options?: {
        query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getItemsId>>, TError, TData>>
        axios?: AxiosRequestConfig
    },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetItemsIdQueryOptions(id, options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }

    query.queryKey = queryOptions.queryKey

    return query
}

export const putItemsId = (id: string, items: Items, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
    return axios.put(`http://localhost:3000/items/${id}`, items, options)
}

export const getPutItemsIdMutationOptions = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof putItemsId>>, TError, { id: string; data: Items }, TContext>
    axios?: AxiosRequestConfig
}): UseMutationOptions<Awaited<ReturnType<typeof putItemsId>>, TError, { id: string; data: Items }, TContext> => {
    const mutationKey = ['putItemsId']
    const { mutation: mutationOptions, axios: axiosOptions } = options
        ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
            ? options
            : { ...options, mutation: { ...options.mutation, mutationKey } }
        : { mutation: { mutationKey }, axios: undefined }

    const mutationFn: MutationFunction<Awaited<ReturnType<typeof putItemsId>>, { id: string; data: Items }> = props => {
        const { id, data } = props ?? {}

        return putItemsId(id, data, axiosOptions)
    }

    return { mutationFn, ...mutationOptions }
}

export type PutItemsIdMutationResult = NonNullable<Awaited<ReturnType<typeof putItemsId>>>
export type PutItemsIdMutationBody = Items
export type PutItemsIdMutationError = AxiosError<unknown>

export const usePutItemsId = <TError = AxiosError<unknown>, TContext = unknown>(options?: {
    mutation?: UseMutationOptions<Awaited<ReturnType<typeof putItemsId>>, TError, { id: string; data: Items }, TContext>
    axios?: AxiosRequestConfig
}): UseMutationResult<Awaited<ReturnType<typeof putItemsId>>, TError, { id: string; data: Items }, TContext> => {
    const mutationOptions = getPutItemsIdMutationOptions(options)

    return useMutation(mutationOptions)
}
export const get = (options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
    return axios.get(`http://localhost:3000/`, options)
}

export const getGetQueryKey = () => {
    return [`http://localhost:3000/`] as const
}

export const getGetQueryOptions = <TData = Awaited<ReturnType<typeof get>>, TError = AxiosError<unknown>>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>
    axios?: AxiosRequestConfig
}) => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetQueryKey()

    const queryFn: QueryFunction<Awaited<ReturnType<typeof get>>> = ({ signal }) => get({ signal, ...axiosOptions })

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }
}

export type GetQueryResult = NonNullable<Awaited<ReturnType<typeof get>>>
export type GetQueryError = AxiosError<unknown>

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = AxiosError<unknown>>(options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
        Pick<
            DefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
            'initialData'
        >
    axios?: AxiosRequestConfig
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = AxiosError<unknown>>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>> &
        Pick<
            UndefinedInitialDataOptions<Awaited<ReturnType<typeof get>>, TError, Awaited<ReturnType<typeof get>>>,
            'initialData'
        >
    axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = AxiosError<unknown>>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>
    axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGet<TData = Awaited<ReturnType<typeof get>>, TError = AxiosError<unknown>>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof get>>, TError, TData>>
    axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetQueryOptions(options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }

    query.queryKey = queryOptions.queryKey

    return query
}

export const getNotFound = (options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
    return axios.get(`http://localhost:3000/not-found`, options)
}

export const getGetNotFoundQueryKey = () => {
    return [`http://localhost:3000/not-found`] as const
}

export const getGetNotFoundQueryOptions = <
    TData = Awaited<ReturnType<typeof getNotFound>>,
    TError = AxiosError<unknown>,
>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotFound>>, TError, TData>>
    axios?: AxiosRequestConfig
}) => {
    const { query: queryOptions, axios: axiosOptions } = options ?? {}

    const queryKey = queryOptions?.queryKey ?? getGetNotFoundQueryKey()

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotFound>>> = ({ signal }) =>
        getNotFound({ signal, ...axiosOptions })

    return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
        Awaited<ReturnType<typeof getNotFound>>,
        TError,
        TData
    > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetNotFoundQueryResult = NonNullable<Awaited<ReturnType<typeof getNotFound>>>
export type GetNotFoundQueryError = AxiosError<unknown>

export function useGetNotFound<TData = Awaited<ReturnType<typeof getNotFound>>, TError = AxiosError<unknown>>(options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotFound>>, TError, TData>> &
        Pick<
            DefinedInitialDataOptions<
                Awaited<ReturnType<typeof getNotFound>>,
                TError,
                Awaited<ReturnType<typeof getNotFound>>
            >,
            'initialData'
        >
    axios?: AxiosRequestConfig
}): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNotFound<
    TData = Awaited<ReturnType<typeof getNotFound>>,
    TError = AxiosError<unknown>,
>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotFound>>, TError, TData>> &
        Pick<
            UndefinedInitialDataOptions<
                Awaited<ReturnType<typeof getNotFound>>,
                TError,
                Awaited<ReturnType<typeof getNotFound>>
            >,
            'initialData'
        >
    axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetNotFound<
    TData = Awaited<ReturnType<typeof getNotFound>>,
    TError = AxiosError<unknown>,
>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotFound>>, TError, TData>>
    axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useGetNotFound<
    TData = Awaited<ReturnType<typeof getNotFound>>,
    TError = AxiosError<unknown>,
>(options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getNotFound>>, TError, TData>>
    axios?: AxiosRequestConfig
}): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
    const queryOptions = getGetNotFoundQueryOptions(options)

    const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
        queryKey: DataTag<QueryKey, TData, TError>
    }

    query.queryKey = queryOptions.queryKey

    return query
}
